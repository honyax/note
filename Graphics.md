# DirectX12の魔導書

[DirectXの魔導書](https://www.amazon.co.jp/dp/4798161934)

1. 前提となる知識とDirectX 12の概略
   - DirectX12は、11以前と比べて難解になっているらしい。パフォーマンスを引き出すために細かい調整が必要とのこと。
2. グラフィックスパイプラインとさまざまなシェーダー
   - グラフィックスのパイプライン、シェーダの紹介
3. 初期化から画面クリアまで
   - #pragma comment(lib, "honya.lib") という記述により、コンパイラ（リンカ）にリンクするライブラリを指定できる<br/>
     #pragma commentは、オブジェクトファイルにコメントを残すという意味である。
   - コマンドリストとは、GPUに対する命令をまとめるためのオブジェクトである。<br/>
     DirectX11ではDeviceContextオブジェクトに都度命令を送ればよかったが、DirectX12では命令をコマンドリストとしてひとまとめにしてGPUに送るという仕様になった。
     しかもDirectX11まではGPUに対する命令の関数を呼べば基本的に即時実行されていたが、DirectX12では遅延実行される。
   - スワップチェーンでダブルバッファの切り替えを可能にし、レンダーターゲットビュー（RTV）でバッファの中身を書き換える
   - ディスクリプタヒープにより、複数のディスクリプタを管理する。RTVのダブルバッファの表裏2つのビューを管理する、など。
   - 3.3までで画面を黄色く塗れるようになった。この時点で実行しても通常はエラーになるらしいが、手元だと何故か問題なく実行できた。<br/>
     ただしデバッグログにエラーメッセージらしきものは出ている。
   - 3.4でデバッグを有効化し、「バリア」「フェンス」の仕組みを導入する。
     - フェンスはGPU側の処理が完了したかを知るための仕組み（待つための仕組みではない）<br/>
       フェンスを使って、GPU側の処理が完了した際のイベント通知を待つことが出来る。
     - リソースバリアは、リソースに対する排他制御が出来る。バリアは、「リソースの状態遷移をGPUに教えるもの」と考えて良い。<br/>
       PRESENT状態のバックバッファをレンダーターゲット状態にし、画面のクリアなどの命令を発行してからPRESENT状態に戻す。
4. ポリゴンの表示
   - 頂点情報は、頂点バッファーを使ってCPUからGPUに転送する
   - 頂点シェーダ、ピクセルシェーダを作成
   - 4.6 シェーダーの読み込みと生成
     - シェーダーオブジェクトは、DirectXではID3DBlob型で扱う。
     - 読み込み＆コンパイルは、D3DCompileFromFile()関数を使う。エラー発生時はエラーメッセージを取り出して表示できる。
   - グラフィックスパイプラインステート<br/>
     グラフィックスパイプラインの設定を定義するためのオブジェクト。シェーダーなども含まれる。<br/>
     ここでは最低限の設定しか行わないが、それでも大量にある。
   - ルートシグネチャ<br/>
     ディスクリプタテーブルをまとめたもの。ディスクリプタテーブルは、ディスクリプタヒープ（テクスチャや定数などのアドレスを1箇所にまとめておくためのヒープ領域）と
     シェーダーのレジスターを関連付けるテーブル<br/>
     ひとまず空のルートシグネチャを作成、設定する。
   - ビューポートとシザー矩形<br/>
     シザー矩形は、ビューポートに出力された画像のうち、実際に画面に映し出す範囲を指定する。
5. ポリゴンにテクスチャを貼り付ける。
   - DirectX11に比べてテクスチャの扱いが面倒になっているとのこと。<br/>
     DirectX12では、テクスチャはグラフィックスパイプラインの流れの外から設定されるデータであり、GPU上のバッファを確保し、そこにデータを転送する。<br/>
     テクスチャはプログラム上は「シェーダーリソース」と呼ばれる。
   - 頂点データにUV座標を追加。頂点はXYZとUVの5つのfloatで構成されることになる。
   - テクスチャの読み込みはDirectXTexライブラリを使って手軽に実装。
   - GPU側への転送は、ID3D12Resource::WriteToSubresource() と ID3D12GraphicsCommandList::CopyTextureRegion() の2種類ある。<br/>
     ここでは前者を使ったが、UMAでなくDMAの時は後者のが良い。公式にも後者を推奨している。キャッシュをCPU側に取るかGPU側に取るかの違い。<br/>
     書籍でも、5章の後半に後者の実装方法＆ソースコードが載っているが、6章以降は前者の手法に戻っている。
   - d3dx12.hという便利ヘッダを導入。コード量をそこそこ減らせる。C#er的には公式でも良いと思うぐらいのもの。
6. 行列による座標変換。
   - 3Dにおける行列を使った計算方法の紹介。
   - 行優先と列優先。一般的な数学は列優先だが、これは掛け算する際に、左へ左へと乗算する。<br/>
     XMMATRIXは行優先、HLSLは列優先で、XMMATRIXの場合は乗算の処理は左から右へ右へと処理するのでコードのイメージ通りだが、HLSLだと逆になる。
   - 行列は「定数バッファー」を使ってCPUからGPUに転送する。
   - 3D空間上で描画するには、ワールド行列、ビュー行列、プロジェクション行列の3つの計算が必要
     - ワールド行列により、対象のワールド座標における位置、回転を定義
     - ビュー行列は、カメラ（位置、注視点、上ベクトル）を定義
     - プロジェクション行列は、画角、アスペクト比、クリッピングの遠近を定義
   - 定数バッファーをアンマップしていない状態（マップしたままの状態）であれば、中身を書き換えるとシェーダーから参照されているメモリの内容を書き換えられる。
     これを使って、対象のワールド行列を毎フレーム更新することで移動や回転することが出来る。
7. PMDの読み込みとモデルの表示。
   - ミクミクダンス用のモデルデータを扱ってDirectX12の学習をするのが本書の主旨なので、無駄にMMDファイルの解説とかがある。
   - モデルデータをPMDファイルと呼ぶ。PMDファイルは、ヘッダ280バイトの後に、頂点情報、インデックス情報がある。
   - 頂点情報は、4バイトの頂点数の後に、頂点毎に座標、法線ベクトル、uv座標、ボーン番号、ボーン影響度、輪郭線フラグの38バイトの情報がある。
   - インデックス情報は、4バイトのインデックス数の後に、2バイトのインデックスｘインデックス数。
   - 深度バッファを導入し、深度テスト（Zテスト）する必要がある。そのためのデプスステンシルバッファーを作る。
     - デプスステンシルバッファーは、1ピクセルあたり32ビットのうち、デプスを24bit、ステンシルを8bitにするか、デプスを32bitにするかを選べる（ここではデプス32bitにしている）
   - ランバートの余弦則により、物体表面の明るさを決定する。要するに光の入射角と法線とのコサイン値を明るさとする。
8. マテリアル（材質）
   - マテリアルは、ディフューズ、スペキュラ、アンビエントのパラメータを持つ
   - PMDファイルにはインデックスの後にマテリアル情報が格納されているので、読み込む
     - マテリアルデータをシェーダーに転送する手順は、いつものごとく以下の手順になる<br/>
       データ格納バッファーを作成、Mapを使ってコピー、ディスクリプタヒープを作成、ディスクリプタヒープ上にビューを作成、ルートパラメータ設定を追加、シェーダー書き換え
   - charとwchar_t
     - wchar_tはC++では「L"ほげほげ"」とか「\_T("ふがふが")」と記述する。
     - それぞれを変換するには、MultiByteToWideChar()、WideCharToMultiByte() というWindowsAPIを使う。
   - ランバートの余弦則で輝度を計算する
   - トゥーンシェーディングでは、輝度の変化に手を加えている。
9. リファクタリング
   - ここまでのコードをキレイにリファクタリングしている。
10. スキニングとアニメーション
    - スキニングにより、関節が曲がっても違和感が無い形で見せる
    - ボーンの構造と動かし方、階層構造でのデータの扱い方
    - アニメーション（数学的な説明がある）
      - クォータニオンと回転行列
      - キーフレーム、モーション間の補間（線形補間とベジェ曲線によるイーズイン・イーズアウトなど）
11. インバースキネマティクス（IK）
    - IKによるノードの位置調整の、数学的な実装方法の説明
      - CCD-IK、パーティクルIK、クォータニオンIK、ヤコビアンIKのうち、CCD-IKを採用
12. マルチパスレンダリング
    - 色データや法線データなど各種画像の出力先をレンダーターゲットと言い、それらを複数枚用意することをマルチパスレンダリングと呼ぶ。
    - 何度もレンダリングを行う過程で、レンダリング結果を（ペラ1のポリゴンの）テクスチャとして扱うことで合成などの加工ができる
    - ぼかし、シャープネス、輪郭抽出などの簡単な画像処理のロジックの解説
13. 影行列とシャドウマップ
    - MMDにおける影は、地面影、セルフ影の2種類
      - 地面影：影行列による実装
      - セルフ影：シャドウマップによる実装（実装の難易度が高い）
    - 影行列の解説（数学的な説明も）
    - シャドウマップの解説
14. マルチレンダーターゲットとその応用
    - マルチパスレンダリングとマルチレンダーターゲットの違い
      - マルチレンダーターゲットは、ピクセルシェーダの出力先が複数になる
      - 色、法線の出力を実装
    - 色・法線情報によるディファードシェーディング
    - ブルーム
    - 被写界深度
15. スクリーンスペースアンビエントオクルージョン（SSAO）
    - アンビエントオクルージョンの説明（数学的説明も）
    - スクリーンスペースアンビエントオクルージョン（SSAO）の実装
16. imguiの利用
    - imguiは、簡易的なGUIライブラリ。
    - imguiの組み込み＆実装方法
    - 主な機能である、チェックボックス、ラジオボタン、スライドバー、カラーピッカーの使い方。
17. Effekseerライブラリの利用
    - Effekseerとは、パーティクルなどによる3Dエフェクトをデザインするためのオープンソースなツール
    - Effekseerで作ったエフェクトをゲーム上で再生するためのライブラリの紹介
    - Effekseerライブラリの組み込み＆実装方法
18. DirectXTKの利用（文字列表示）
    - DirectXTK（DirectX Tool Kit）は、DirectXのヘルパークラスやヘルパー関数の集合体
    - 比較的簡単にDirectX12製のゲームやアプリケーションを作ることができるようになる
    - 本書では、フォントを指定した文字列の表示のみを扱う（かなり大きなライブラリなのでその他の機能はスルー）
      - 本書ではあえてDirectXTKを使わずに、低レイヤ部分の解説をしてきた。
    - DirectXTKの組み込み＆フォント指定の文字列（日本語含む）表示方法の解説


# HLSLシェーダーの魔導書

[HLSLシェーダーの魔導書](https://www.amazon.co.jp/dp/4798164283)
1. レンダリングパイプライン入門
   - CPUとGPU
     - CPUとGPUの違いの説明。コア数と得意分野など
   - メインメモリとグラフィックスメモリ
     - CPUとGPUの異なるメモリについて。DMAによるデータの転送。
   - 絵が表示されるまでの流れ
     - レンダリングパイプラインの説明
2. はじめてのシェーダー
   - DirectX 7.1以前のレンダリングパイプライン
   - シェーダーの導入
     - 過去のDirectXでは決まりきった表現しか出来ず、アニメ調の表現などは不可能だった。
   - 頂点シェーダー入門
     - 三角形を表示するシンプルなプログラムを実装し、様々な変形を試す
   - ピクセルシェーダー入門
     - 三角形に色を付けてみる
3. シェーダープログラミングの基本
   - 座標変換
     - 行列とベクトルの乗算、様々な座標空間、CPUからGPUへのメモリ転送
     - 三角形を動かしてみる
   - テクスチャマッピング
     - UV座標によるテクスチャ貼り付け。三角形にテクスチャを貼り付けてみる
   - 複雑な3Dモデルの表示へ
     - 本書独自フォーマットとして、「.tkm」ファイルを使う。MaxやBlenderで作成したモデルから、頂点バッファー、インデックスバッファー、マテリアル情報を抽出したもの。
4. ライティング基礎
   - ライティングなしの3Dモデル表示
   - ライトの種類
     - ディレクショナルライト、ポイントライト、スポットライト
   - 反射：Phongの反射モデル
     - 拡散反射光、鏡面反射光、環境光の実装
5. ライティング発展
   - ポイントライト
   - スポットライト
   - リムライト
     - 逆光ライト。対象の後方から光が指し、輪郭がうっすら光る表現。
   - 半球ライト
     - 環境光より少しだけリアルなライト。
6. さまざまなテクスチャの利用
   - 法線マップ
     - オブジェクトスペース法線マップと、タンジェントスペース法線マップ
     - メインはタンジェントスペース法線マップ。こちらを利用した実装を行う。
   - スペキュラマップ
     - 鏡面反射の強さを書き込んだテクスチャの実装。
   - アンビエントオクルージョンマップ（AOマップ）
     - 環境光の強さを表すAOマップの実装。
7. PBR（物理ベースレンダリング）
   - PBRとは
     - PPS4やXbox Oneなどの登場によりトレンドになった技術。物理法則に従ってライティング計算する。
     - エネルギー保存の法則、ヘルムホルツの相反性
   - ディズニーの論文によるPBR
     - 「塔の上のラプンツェル」」の髪の毛表現のために開発した。それ以降の映画では、髪の毛以外にも適用するようになった。
     - PBRに必要な各種パラメータの説明と、ディズニーの論文をベースにしたPBRの実装。
8. 2D描画の基礎
   - DirectX 12で2D描画
     - 2Dは3Dの板ポリへの描画となる。
   - 2D表示
   - αブレンディング
     - 半透明合成、加算合成
9. 発展的な2D描画
   - リニアワイプ
     - 画面切り替えなどシーン遷移などに使われる演出演出
     - 直線的なワイプの実装
   - その他のワイプ
     - 円形、縞模様、チェッカーボード模様のワイプ
   - 画像の色を変化させる
     - モノクロ、セピア、ネガポジ反転、ノイズによるワイプ
10. ポストエフェクト
    - オフスクリーンレンダリング
      - 画面に表示されないレンダリング
    - モノクロ化
    - ブラー
      - 平均ブラー、ガウシアンブラー
    - ブルーム
    - 川瀬式ブルームフィルター
    - 被写界深度
      - カメラのピンぼけ演出を作る技術
    - カメラの絞りによる六角形ブラー
11. シャドウイング
    - 投影シャドウ
      - シャドウマップ
    - デプスシャドウ
      - 投影シャドウの欠点を補い、発展させたもの
    - PCF（Percentage Closer Filtering）
      - 最も簡単にソフトシャドウを実現出来る技術
    - VSM（Variance Shadow Maps）
      - PCFより高品質なソフトシャドウを実現する技術。分散シャドウマップ。
    - カスケードシャドウ
      - 現在のハイエンドゲームでは、「カスケードシャドウ＋ソフトシャドウ」がデファクト。
12. ディファードレンダリング
    - フォワードレンダリングとは
      - ポリゴンをレンダリングするときにライティングの計算を行うもの。これまで実装してきたものは全てフォワードレンダリング
    - ディファードレンダリングとは
      - ポリゴンをレンダリングするときにはライティングの計算は行わずに、その後に行うもの
      - ライティングの計算をポストエフェクト的に行う
      - Deffered : 遅延
    - ディファードレンダリングのメリット
      - フォワードレンダリングでは先にライティングを行うため、不要なピクセルのライティングも計算されてしまう
    - ディファードレンダリングのデメリット
      - メモリ使用量の増大、書き込み料の増大
      - Xbox360では、VRAMの拘束メモリ転送が可能なメモリ容量が小さかったため、ディファードレンダリングは（PS3に比べて）あまり採用されなかった。
      - 半透明オブジェクトの描画に弱い
    - ディファードレンダリング入門 ～拡散反射～
    - ディファードレンダリング入門 ～鏡面反射～
    - ディファードレンダリング入門 ～法線マップ～
    - ディファードレンダリング入門 ～スペキュラマップ～
13. ディファードレンダリングとフォワードレンダリングの融合
    - 半透明問題
      - ディファードレンダリングしているモデルの手前に板ポリを置くと、G-Bufferが上書きされて陰影などが描画されなくなる
    - ハイブリッドエンジンの実装
      - 不透明モデルをディファーどレンダリングした後に、半透明オブジェクトのピクセルシェーダをフォワードレンダリングでライティング計算する
14. 3Dゲームで使える発展的シェーダー
    - レンダリングエンジン
      - 本書オリジナルのレンダリングエンジンによる処理の流れ
    - レンダリングエンジンのカスタマイズ
      - レンダリングエンジンを自力でカスタマイズすることの意義
    - 輪郭線の描画
    - ステルス処理
    - ディザリング
      - ディザリングは、ディファードレンダリングとの相性が良い半透明描画手法
15. コンピュートシェーダー
    - GPGPUとは
      - GPUに画像処理以外の処理を行わせること
      - コリジョン処理、仮想通貨のマイニング、機械学習など
    - コンピュートシェーダーとは
      - DirectComputeというAPI
    - データの入力と出力
    - 構造化バッファー
      - シェーダーへの入力と出力の両方に構造化バッファーを使う
    - アンオーダーアクセスビューとシェーダーリソースビュー
      - ピクセルシェーダ、頂点シェーダの場合はリソースを入力するだけだが、コンピュートシェーダーは入出力を行う
      - ここでは入力にはシェーダーアクセスビュー（読み取り専用）、出力にはアンオーダーアクセスビュー（順序指定されていないアクセスビュー）を使ってGPUからランダムアクセスする
    - 学生の平均点を計算するプログラムを眺めてみる
    - 合計点を出力するように改造する
    - 標準偏差を計算する
    - コンピュートシェーダーの並列処理
16. TBR（Tile Based Rendering）
    - ポイントライト再び
      - TBRは、大量の動的光源を拘束に扱うための手法。実装にはコンピュートシェーダを使う。
      - 光源（主にポイントライト）が多くなると3Dレンダリングは重くなる。
    - TBDR（Tile Based Deffered Rendering）
    - TBFR（Tile Based Forward Rendering）
17. レイトレーシング
    - レイトレーシングとは
      - 光の伝搬をシミュレーションしてリアルなCGを表現する
      - 非常に処理負荷が高い
      - NVIDIAがリアルタイムレイトレーシングを行うための専用プロセッサを搭載したRTXシリーズを発表
      - MicrosoftがDirectXにリアルタイムレイトレーシングを行うためのAPIセット「DirectX Raytracing(DXR)」を公開
      - PS5もリアルタイムレイトレーシング対応のGPUを搭載
    - レイトレーシング法とラスタライザー法の違い
    - レイトレーシング超入門
    - テクスチャマッピング
    - 2次反射
    - DirectX Raytracing（DXR）


# ゲーム制作者になるための3Dグラフィックス技術 改訂3版
[ゲーム制作者になるための3Dグラフィックス技術 改訂3版](https://www.amazon.co.jp/dp/4295007862)

