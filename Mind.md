# [UNIXという考え方](https://www.amazon.co.jp/dp/4274064069/)

#### UNIX の定理<br/>
定理1. スモール・イズ・ビューティフル<br/>
定理2. 一つのプログラムには一つのことをうまくやらせる<br/>
定理3. できるだけ早く試作を作成する<br/>
定理4. 効率より移植性<br/>
定理5. 数値データは ASCII フラットファイルに保存する<br/>
定理6. ソフトウェアの梃子を有効に活用する<br/>
定理7. シェルスクリプトを使うことで梃子の効果と移植性を高める<br/>
定理8. 過度の対話的インタフェースを避ける<br/>
定理9. すべてのプログラムをフィルタにする<br/>
#### さらなる 10 の UNIX の考え方<br/>
(1) 好みに応じて自分で環境を調整できるようにする<br/>
(2) オペレーティングシステムのカーネルを小さく軽くする<br/>
(3) 小文字を使い、短く<br/>
(4) 森林を守る<br/>
(5) 沈黙は金<br/>
(6) 並行して考える<br/>
(7) 部分の総和は全体よりも大きい<br/>
(8) 90 ％の解を目指す<br/>
(9) 劣るほうが優れている<br/>
(10) 階層的に考える<br/>
<br/>
小さなプログラム<br/>
一つのことだけに専念<br/>
学習し続ける<br/>
早期の試作<br/>
試作は、一つのことだけを行う小さなプログラムで徐々に進める<br/>
ソフトウェアは作るものでなく成長していくもの<br/>
移植可能なアプリケーションと移植性のあるデータ<br/>
移植可能なソフトウェアを未来のハードウェアで動かす<br/>
プログラマの仕事は複利計算で増大<br/>
シェルスクリプトによる抽象化<br/>
小さなプログラムのコレクションをシェルスクリプトで組み合わせる。応答を要求しない。<br/>

# [達人プログラマー](https://www.amazon.co.jp/dp/4274226298)
##### 達人の哲学
・割れた窓を放置しておかないこと。すぐにコードが悪化する。<br/>
・変化の触媒たれ（石のスープの話）<br/>
・品質要求を明確にする（速度優先か、クオリティ優先か）<br/>
・知識ポートフォリオを作成する<br/>
　＞毎年言語を1つ学習する<br/>
　＞月に1冊技術書を読む。<br/>
　　＞実装・コーディングを行っていれば設計やアーキテクチャの書籍を、<br/>
　　＞抽象度の高い設計を行っているのであればコーディングテクニックの書籍を<br/>
　＞技術書以外の書籍を読む、講習を受講する、ユーザーグループに参加する<br/>
　＞異なった環境に慣れ親しんでみる（Windows から Linux へ、など）<br/>
　＞最先端にとどまり続ける<br/>
・批判的な目で見る<br/>
　＞5 回は「なぜ？」を問いかける。4 歳の子供のように<br/>
　＞誰にメリットがあるのか？コンテキストは何か？いつ、どこで有効になるのか？なぜこれが問題なのか？<br/>
##### 達人のアプローチ
・良い設計は悪い設計よりも変更しやすい<br/>
・ETC(Easy To Change)原則、DRY(Don't Repeat Yourself)原則<br/>
・直交性：関係のないもの同士の影響を排除する<br/>
・最終決定などというものは存在しない<br/>
・暗闇の中で曳光弾を撃つ<br/>
　＞まずはシステム全体を横断する一つの機能を実装する。それを目安に改良・実装を進める。<br/>
　＞プロトタイピングは見た目の同意を得るもの（コードは破棄する）、曳光弾は設計の目安を見つけるもの（コードを破棄しない）<br/>
##### 妄想の達人
・契約による設計（DbC:Design by Contract）<br/>
・死んだプログラムは嘘をつかない（早めにクラッシュさせること）<br/>
・起こり得ないことは assert する<br/>
・はじめたことは終わらせる（ものごとを局所的にする）<br/>
　＞参照に null を代入する、など<br/>
・ヘッドライトを追い越さない。常に少しずつ進め、予言は避ける<br/>
#### 柳に雪折れ無し
・分離されたコードは変更しやすい<br/>
・グローバルデータを避ける。グローバルなデータにするほど重要なものは、API でラップする<br/>
・FSM を活用する<br/>
・Observer パターンでイベントを通知<br/>
・Publish/Subscribe プロトコルを活用する<br/>
・インヘリタンス（相続）税を払わないこと<br/>
　＞代わりにインタフェースとプロトコル、委譲、mixin と trait を活用することを検討する<br/>
　＞継承が最適解になることは滅多にない<br/>
・外部設定を用いてアプリをパラメータに対応させる<br/>
　＞形式は YAML や JSON など。参照する場合は薄い API でラップする<br/>
#### 並行性
・並行性を向上させるためにワークフローを分析する<br/>
　＞並行実行出来るものと順序依存性があるものを区別する<br/>
・共有状態は間違った状態。セマフォ、排他制御を行う<br/>
・ホワイトボードを使って情報の共有、メッセージシステムを作る<br/>
#### コーディング段階
・コーディング中にぬかるみにハマったと感じたら、手を止めて散歩やおしゃべり、休憩に入るか、以下の行動を試してみる<br/>
　＞ポストイットに「現在プロトタイピング中」と書いて、画面の横に貼っておく<br/>
　＞プロトタイピングは失敗するために行う。そして作ったコードは全て捨て去る<br/>
　＞実行すること、学習したいことを 1 行にまとめてまっさらなエディタに記述する<br/>
・アルゴリズムのスピードには O 記法を用いる。O(n), O(log n), O(n^2) など<br/>
・リファクタリングは早めに、こまめに、小さく実行していく<br/>
・テストはコードのユーザー第一号である<br/>
　＞テスト駆動開発（TDD）を行う<br/>
　＞著者は 30 年間テストコードを書き続けた結果、テストコードを書かなくても適切なコードを書けるようになった<br/>
　　30 年間テストコードを書き続けて、かつ他人と共有しない自分だけのコードに対しては、テストコードを書かなくても良い<br/>
#### プロジェクトを始める前に
・プログラマの仕事は、人々自身が欲しているものを気づいてもらえるよう支援することである<br/>
　＞要求事項が事前に網羅されていることはありえない<br/>
　＞要求はフィードバックループの中で学んでいくものである<br/>
・自分自身がユーザーとなる<br/>
・ペアプログラミングを行う<br/>
#### 達人のプロジェクト
・小規模で安定したチームを作る<br/>
・どんな状況にも適用できる万能の方策など存在しない<br/>
・真のゴールを見極める<br/>
　＞ユーザーが必要としたタイミングで調達する<br/>
・バージョン管理の活用、容赦なく継続的なテスト、自動的なビルド<br/>
　＞コードのカバレッジではなく、状態のカバレッジをテストすること<br/>
　＞手作業を排除する<br/>
・極悪なことを実行できるようにしない<br/>
