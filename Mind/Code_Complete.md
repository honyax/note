# [CODE COMPLETE 第2版 上](https://www.amazon.co.jp/dp/489100455X)
### 第１部 基礎を固める
##### 第１章 ソフトウェアコンストラクションへようこそ
### 第２部 高品質なコードの作成
### 第３部 変数
### 第４部 ステートメント

# [CODE COMPLETE 第2版 下](https://www.amazon.co.jp/dp/4891004568)
### 第５部 コードの改良
##### 第２０章 ソフトウェアの品質
欠陥の検出には、プロトタイピング、セルフレビュー、コードレビュー、単体＆結合テスト、ベータテストなどの組み合わせが有効。<br/>
220 行程度のコードを 166 名のプログラマに書かせた所、コーディング時間が中間程度のものが最もエラーが多かった。<br/>
最速、最遅のものはむしろエラーが少なかった。<br/>

##### 第２１章 コラボレーティブコンストラクション
一部のコードのみを対象にしたペアプログラミングは非常に有効。<br/>

##### 第２２章 デベロッパーテスト
テストケースの数は、直線のルーチンを 1、if, while, for などの分岐で 1、case 文の個数で 1 という具合に計算する。<br/>
コードよりも先にテストケースを書くと、時間や労力は変わらないが、欠陥検出・修正のサイクルは短くなる。<br/>

##### 第２３章 デバッグ
※ この章に書かれている内容は近年の IDE の機能向上で大分未然に防止できている。<br/>

##### 第２４章 リファクタリング
※ リファクタリングについての詳細は、[リファクタリング(第2版): 既存のコードを安全に改善する](https://www.amazon.co.jp/dp/4274224546)を参照。<br/>
リファクタリングの種類：<br/>
　データレベル・ステートメントレベル・ルーチンレベル・クラス実装・クラスインターフェイス・システムレベル<br/>

##### 第２５章 コードチューニング戦略
パフォーマンスはコードの速度とさほど関係しない。コードの速度に取り組めば、他の品質特性を犠牲にしてしまう。<br/>
パレートの法則（80 対 20 の法則）。プログラムの実行時間の 80% は、20% のルーチンによって消費される。<br/>
Jackson の最適化の法則。法則１：最適化しない。法則２：まだ最適化しない。完全に明白で最適化を使用しない解決策が見つかるまでは。<br/>
非効率の一般的な原因：I/O 処理、ページング、システムコール、インタプリタ言語、エラー。<br/>
パフォーマンスのボトルネックをデータ無しで予測・分析出来るプログラマは存在しない。<br/>

##### 第２６章 コードチューニングテクニック
様々なチューニングの手法が紹介されているが、コーディングレベルのチューニングはほぼ無意味である。<br/>
可読性を犠牲にしてまで施すコーディングレベルのチューニングは基本的には存在しない。<br/>
強いていうならば、sqrt, log, sin などの math 関連のアルゴリズムに注意し、スキップできるならばスキップすべき。<br/>

### 第６部 システムの考察
##### 第２７章 
##### 第２８章 
##### 第２９章 
##### 第３０章 

### 第７部 ソフトウェア職人気質とは
##### 第３１章 
##### 第３２章 
##### 第３３章 
##### 第３４章 
##### 第３５章 
